\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}

\title{COMP330-A3}
\author{Delana Ryan}
\date{February 2026}

\begin{document}

\maketitle

\section{Q1}
Question 1 [30 points] ”Show that the following languages are context-free by making a context-free grammar for each of them. For each case, you do not need to give a formal proof that your grammar is correct, but you must explain, at least briefly, why it works (i.e. why any string generated by G is in L, and why any word in L can be generated by G). \newline
a.$ \{a^n b^m c^p|n \leq p \text{ or } m \leq p\}$ \newline
\indent \textbf{Sol:} \newline
OR $\implies \Sigma_1 = \{a^nb^mc^p|n\leq p\} \cup \Sigma_2 =  \{a^nb^mc^p | m \leq p\}$ \newline $\Sigma_1: S_1 \rightarrow AB; A \rightarrow aAc|C; C\rightarrow cC|\epsilon; B \rightarrow bB|\epsilon$ \newline
This defines $\Sigma_1$, as each time we add an $a$, we also add a $c$, ensuring the condition $n\leq p$ is met. $b$s are added arbitrarily. \newline
$\Sigma_2: S_2\rightarrow AB; A\rightarrow aA | \epsilon; B \rightarrow bBc | C; C\rightarrow cC|\epsilon$ \newline
Similarly to $\Sigma_1,$ to meet the condition $m \leq p$, we add a $c$ for each $b$ that is added. $a$s can be any number. So, the grammar is represented: $S\rightarrow S_1|S_2$. 

\newpage
b. $\{a^m b^n c^p d^q|m + n = p + q\}$ \newline
\indent \textbf{Sol:} \newline
To represent this language as a CFG, we can divide $a^mb^m$ into the left side $m+n$, and $c^pd^q$ into the right side $p+q$. Then, we must make sure both sides are equal in length. \newline
So: $S \rightarrow aSc | aSd | bSc | bSd|\epsilon$, for each left side symbol we add an equivalent number of right side symbols, ensuring $m+n=p+q$

\newpage
c. The set of words over the alphabet $\{a, b\}$ of even length where the number of occurrences of $b$ in even positions is the same as the number of occurrences of $b$ in odd positions. \newline
\indent \textbf{Sol:} \newline
To represent this as a CFG, we have to balance even and odd $b$s substrings $aa$ and $bb$ are already balanced, and can be added any number of times. The strings $ab$ and $ba$ must occur an equal number of times. \newline
So: $S_1 \rightarrow aaS|bbS|S_2|\epsilon; S_2\rightarrow abS_2ba|abS_1ba|baS_2ab|baS_1ab$. 

\newpage
\section{Q2} 
Use the pumping lemma to show that the following language is not context free: $\{0^n1^n0^n1^n|n \geq 0\}$ \newline
\indent \textbf{Sol:} \newline
Note: Pumping lemma implies there exists some $p$ such that any string $s$ with length $\geq p$ can be decomposed: $s=uvxyz$ $\rightarrow uv^ixy^iz,$ with $|vxy| \leq p, |vy| >0$ for all $i \geq 0$.  \newline
Assume, for contradiction, that the language is context free. Consider the string $s=0^p1^p0^p1^p$. Since $|vxy| \leq p, vxy$ cannot cover both sections of $0s$ in the string $0^p1^p0^p1^p$. So, if $v$ and $y$ contain only 0s the string $0^{p+k}1^p0^p1^1$ no longer is part of the language, and if they contain at least one 1, the string $0^{p}1^{p+k}0^p1^p$ is also no longer in the language. So, L is not context free.  

\newpage
\section{Q3}
Let $\Sigma = \{0, 1\}$ and let $B$ be the collection of strings that contain at least one 1 in their last part. That is, $B = \{uv|u \in \Sigma^*, v \in \Sigma^{*}1\Sigma^* \text{ and } |u| \geq |v|\}$
a. Give a CFG that generates B. \newline
\indent \textbf{Sol:} \newline
$S_1 \rightarrow 0S0|0S1|1S0|1S1|S_2$ ensures that $|u| = |v|.$ \newline
$S_2 \rightarrow 0S_2| 1S_2|1S_3$ allows $|u| > |v|$ and forces at least $1 \text{ in } S_3$. \newline
$S_3 \rightarrow 0S_3|1S_3|\epsilon$ for some continuation. 

\newpage
b. Give a PDA that recognizes B. \newline
\indent \textbf{Sol:}
Note, $PDA = (Q, \Sigma, \Gamma, \delta, q_0, Z, F)$.
Consider Q with states $Q=\{q_0, q_1, q_\text{seen}, q_{acc}\}$ where $q_0, q_1$ are reading in parts $u$ and $v$ respectively. $q_{\text{seen}}$ if we are in section $v$ and have already seen at least one 1, and the accept state $q_{acc}$. \newline
Let our PDA read the first part (u) by, for any input, push a * for each symbol read: $\delta(q_0,a,s) = \{(q_0, *s)\}$, to count the length of $u$. \newline
Use some nondeterministic guess to switch to the second half, $v$: $\delta(q_0,\epsilon, s)=\{(q_1,s)\}$. \newline
For each symbol read in $v,$ pop a *. $\delta(q_1,a,*)$ if $a=0$. \newline If $a=1, \delta(q_1,1,*)=\{(q_{\text{seen}}, \epsilon)\}$. Continue popping, then accept when the input ends, ensuring $|u|\geq|v|$.

\newpage 
\section{Q4}
 Let $G = (V, \Sigma, R,⟨stmt⟩)$ be the following grammar.
$⟨stmt⟩ \rightarrow ⟨assign⟩|⟨if-then⟩|⟨if-then-else⟩$
$⟨if-then⟩ \rightarrow \text{if condition then} ⟨stmt⟩$
$⟨if-then-else⟩ \rightarrow \text{if condition then } ⟨stmt⟩ \text{ else } ⟨stmt⟩$
$⟨assign⟩ \rightarrow a:=1$
$\Sigma = \{if, condition, then, else, a:=1\}$
$V = \{⟨stmt⟩,⟨if-then⟩,⟨if-then-else⟩,⟨assign⟩\}$
G is a natural-looking grammar for a fragment of a programming language, but G is ambiguous. \newline 
a. Show that G is ambiguous. [5 points] \newline
\indent \textbf{Sol:} \newline
A grammar is ambiguous if it has at least one string that can be derived by two different parse trees. \newline
Consider the string "if condition then if condition then a:=1 else a:=1". This string has two derivations: \newline
1. if condition then \newline
\indent if condition then \newline
\indent \indent a:=1 \newline
\indent else 
\indent \indent a:=1 \newline
or \newline
2. if condition then \newline
\indent if condition then \newline
\indent \indent a:=1 \newline 
else \newline
\indent a:=1 \newline 
Since we can interpret this string in two ways, the grammar is ambiguous. \newline

\newpage
\indent \textbf{Sol:} \newline
b. Give a new unambiguous grammar for the same language. (You don’t need a formal proof that it is unambiguous). [10 points] \newline
This grammar can be made unambiguous by matching each if with its respective else. So, we will define a new grammar to indicate wether a if/else condition is open (if without a clear closing else, and vice versa) or closed.\newline
$<stmt> \rightarrow <closed>|<open>$\newline
$<closed> \rightarrow a:=1 | \text{ if condition then} <closed> else <closed>$ \newline
$<open> \rightarrow \text{if condition then} <stmt> | \text{if condition then} <closed> else <open>$ \newline

\newpage
\section{Q5}
Consider a context-free grammar restricted to this form: \newline
1. $X \rightarrow aY$ for any variables X, Y and any terminal a \newline
2. $X \rightarrow \epsilon$ for any variable X \newline
3. $X \rightarrow a$ for any variable X and any terminal a \newline
Show that any context-free grammar in this form generates a regular language. \newline
\indent \textbf{Sol:} \newline
All transitions result in either a single terminal followed by at most one variable, or epsilon. This means there is at most one variable on the right hand side, which must appear at the end of the string. These rules essentially function as transitions, with variables acting as states. This grammar has no recursion and no use of the stack, and so it indeed forms a regular language. 

\newpage
\section{Q6} 
In class, we saw that if we have two context-free grammars, then we can make a context-free grammar for their union. This implicitly shows that context-free languages are closed under union. \newline
a. Show that context-free languages are closed under concatenation by showing how to make a context-free grammar that generates language A ◦ B given a context-free grammar that generates A and one that generates B \newline
\indent \textbf{Sol:} \newline
Consider two CFGs: $G_A = (V_A, \Sigma, \delta_A, S_A)$ and $G_B = (V_B, \Sigma, \delta_B, S_B)$ \newline
Let $G=(V_A \cup V_B \cup \{S\}, \Sigma, \delta, S)$. \newline
Let $\delta = \delta_A \cup \delta _B \cup \{S \rightarrow S_AS_B\}$ \newline
So, $S_A$ can generate any string in $A$ and $S_B$ can generate any string in $B$, allowing $G$ to generate any string in $A◦B $, so context-free languages are closed under concatenation. 

\newpage 
b. Show that context-free languages are closed under Kleene star by showing how to make a
context-free grammar that generates language A∗ given a context-free grammar that generates
A. \newline
\indent \textbf{Sol:} \newline
Let $G_A = (V, \Sigma, \delta, S_A)$. Let the start variable be $S$, making $G=(V \cup \{S\}, \Sigma, \delta \cup \{S \rightarrow S_AS | \epsilon, S\}$. \newline
Note that $S \rightarrow S_AS$ generates a string from $A$ and then repeats until $\epsilon$. So, we generate $x_1x_2...x_k$ for any $k\geq 0$ showing that CFls are closed under Kleene star. 

\newpage
c. We have now showed that the context-free languages are closed under the regular operations
(union, concatenation, star). However, the context-free languages are not closed under some
other operations for which the regular languages are closed. Show that context-free languages
are not closed under intersection by giving an example of two context-free languages for which
the intersection is not context-free. \newline
\indent \textbf{Sol:} \newline
Consider two context free languages, $L_1=\{a^nb^nc^m|n,m \geq 0\}$ and $L_2 = \{a^mb^nc^n|m,n \geq 0\}$. These are context-free as in both cases, two variables must be matching in length $n$. \newline
Their intersection, $L_1\cap L_2 = \{a^nb^nc^n|n\geq0\}$, which is not context free. So, CFLs are not closed under intersection. 

\newpage
d. Use the previous fact to show that context-free languages are not closed under complement. \newline
\indent \textbf{Sol:} \newline
By De Morgan's Law, $A\cap B = (A' \cup B')'$, but since we know that CFLs are not closed under intersection, they also cannot be closed under complement. 

\end{document}
